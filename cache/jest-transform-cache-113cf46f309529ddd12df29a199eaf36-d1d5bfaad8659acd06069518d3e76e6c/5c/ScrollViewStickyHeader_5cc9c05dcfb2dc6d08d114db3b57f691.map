{"version":3,"names":["AnimatedView","Animated","View","ScrollViewStickyHeaderWithForwardedRef","React","forwardRef","ScrollViewStickyHeader","props","forwardedRef","inverted","scrollViewHeight","hiddenOnScroll","scrollAnimatedValue","_nextHeaderLayoutY","nextHeaderLayoutY","useState","measured","setMeasured","layoutY","setLayoutY","layoutHeight","setLayoutHeight","translateY","setTranslateY","setNextHeaderLayoutY","isFabric","setIsFabric","componentRef","useRef","_setNativeRef","setAndForwardRef","getForwardedRef","setLocalRef","ref","current","setNextHeaderY","value","stateNode","canonical","offset","useMemo","diffClamp","interpolate","extrapolateLeft","inputRange","outputRange","initialTranslateY","add","animatedTranslateY","setAnimatedTranslateY","_haveReceivedInitialZeroTranslateY","_timer","useEffect","animatedValueListener","useCallback","_debounceTimeout","Platform","OS","clearTimeout","setTimeout","stickStartPoint","push","collisionPoint","newAnimatedTranslateY","animatedListenerId","addListener","removeListener","_onLayout","event","nativeEvent","layout","y","height","onLayout","child","Children","only","children","passthroughAnimatedPropExplicitValues","style","transform","nativeID","styles","header","cloneElement","fill","undefined","StyleSheet","create","zIndex","position","flex"],"sources":["ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\nimport setAndForwardRef from 'react-native/Libraries/Utilities/setAndForwardRef';\nimport Platform from '../../Utilities/Platform';\nimport StyleSheet from '../../StyleSheet/StyleSheet';\nimport Animated from '../../Animated/Animated';\nimport * as React from 'react';\nimport {useEffect, useMemo, useRef, useCallback} from 'react';\n\nconst AnimatedView = Animated.View;\n\nexport type Props = $ReadOnly<{\n  children?: React.Element<$FlowFixMe>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: Animated.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n  nativeID?: ?string,\n  hiddenOnScroll?: ?boolean,\n}>;\n\nconst ScrollViewStickyHeaderWithForwardedRef: React.AbstractComponent<\n  Props,\n  $ReadOnly<{\n    setNextHeaderY: number => void,\n    ...$Exact<React.ElementRef<typeof AnimatedView>>,\n  }>,\n> = React.forwardRef(function ScrollViewStickyHeader(props, forwardedRef) {\n  const {\n    inverted,\n    scrollViewHeight,\n    hiddenOnScroll,\n    scrollAnimatedValue,\n    nextHeaderLayoutY: _nextHeaderLayoutY,\n  } = props;\n\n  const [measured, setMeasured] = React.useState<boolean>(false);\n  const [layoutY, setLayoutY] = React.useState<number>(0);\n  const [layoutHeight, setLayoutHeight] = React.useState<number>(0);\n  const [translateY, setTranslateY] = React.useState<?number>(null);\n  const [nextHeaderLayoutY, setNextHeaderLayoutY] = React.useState<?number>(\n    _nextHeaderLayoutY,\n  );\n  const [isFabric, setIsFabric] = React.useState<boolean>(false);\n\n  const componentRef = React.useRef<?React.ElementRef<typeof AnimatedView>>();\n  const _setNativeRef = setAndForwardRef({\n    getForwardedRef: () => forwardedRef,\n    setLocalRef: ref => {\n      componentRef.current = ref;\n      if (ref) {\n        ref.setNextHeaderY = value => {\n          setNextHeaderLayoutY(value);\n        };\n        setIsFabric(\n          !!(\n            // An internal transform mangles variables with leading \"_\" as private.\n            // eslint-disable-next-line dot-notation\n            ref['_internalInstanceHandle']?.stateNode?.canonical\n          ),\n        );\n      }\n    },\n  });\n\n  const offset = useMemo(\n    () =>\n      hiddenOnScroll === true\n        ? Animated.diffClamp(\n            scrollAnimatedValue\n              .interpolate({\n                extrapolateLeft: 'clamp',\n                inputRange: [layoutY, layoutY + 1],\n                outputRange: ([0, 1]: Array<number>),\n              })\n              .interpolate({\n                inputRange: [0, 1],\n                outputRange: ([0, -1]: Array<number>),\n              }),\n            -layoutHeight,\n            0,\n          )\n        : null,\n    [scrollAnimatedValue, layoutHeight, layoutY, hiddenOnScroll],\n  );\n\n  const [\n    animatedTranslateY,\n    setAnimatedTranslateY,\n  ] = React.useState<Animated.Node>(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n    const initialTranslateY: Animated.Interpolation = scrollAnimatedValue.interpolate(\n      {\n        inputRange,\n        outputRange,\n      },\n    );\n\n    if (offset != null) {\n      return Animated.add(initialTranslateY, offset);\n    }\n    return initialTranslateY;\n  });\n\n  const _haveReceivedInitialZeroTranslateY = useRef<boolean>(true);\n  const _timer = useRef<?TimeoutID>(null);\n\n  useEffect(() => {\n    if (translateY !== 0 && translateY != null) {\n      _haveReceivedInitialZeroTranslateY.current = false;\n    }\n  }, [translateY]);\n\n  // This is called whenever the (Interpolated) Animated Value\n  // updates, which is several times per frame during scrolling.\n  // To ensure that the Fabric ShadowTree has the most recent\n  // translate style of this node, we debounce the value and then\n  // pass it through to the underlying node during render.\n  // This is:\n  // 1. Only an issue in Fabric.\n  // 2. Worse in Android than iOS. In Android, but not iOS, you\n  //    can touch and move your finger slightly and still trigger\n  //    a \"tap\" event. In iOS, moving will cancel the tap in\n  //    both Fabric and non-Fabric. On Android when you move\n  //    your finger, the hit-detection moves from the Android\n  //    platform to JS, so we need the ShadowTree to have knowledge\n  //    of the current position.\n  const animatedValueListener = useCallback(\n    ({value}) => {\n      const _debounceTimeout: number = Platform.OS === 'android' ? 15 : 64;\n      // When the AnimatedInterpolation is recreated, it always initializes\n      // to a value of zero and emits a value change of 0 to its listeners.\n      if (value === 0 && !_haveReceivedInitialZeroTranslateY.current) {\n        _haveReceivedInitialZeroTranslateY.current = true;\n        return;\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n      _timer.current = setTimeout(() => {\n        if (value !== translateY) {\n          setTranslateY(value);\n        }\n      }, _debounceTimeout);\n    },\n    [translateY],\n  );\n\n  useEffect(() => {\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted === true) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    let newAnimatedTranslateY: Animated.Node = scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n\n    if (offset != null) {\n      newAnimatedTranslateY = Animated.add(newAnimatedTranslateY, offset);\n    }\n\n    // add the event listener\n    let animatedListenerId;\n    if (isFabric) {\n      animatedListenerId = newAnimatedTranslateY.addListener(\n        animatedValueListener,\n      );\n    }\n\n    setAnimatedTranslateY(newAnimatedTranslateY);\n\n    // clean up the event listener and timer\n    return () => {\n      if (animatedListenerId) {\n        newAnimatedTranslateY.removeListener(animatedListenerId);\n      }\n      if (_timer.current != null) {\n        clearTimeout(_timer.current);\n      }\n    };\n  }, [nextHeaderLayoutY, measured, layoutHeight, layoutY, scrollViewHeight, scrollAnimatedValue, inverted, offset, animatedValueListener, isFabric]);\n\n  const _onLayout = (event: LayoutEvent) => {\n    setLayoutY(event.nativeEvent.layout.y);\n    setLayoutHeight(event.nativeEvent.layout.height);\n    setMeasured(true);\n\n    props.onLayout(event);\n    const child = React.Children.only(props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  const child = React.Children.only(props.children);\n\n  // TODO T68319535: remove this if NativeAnimated is rewritten for Fabric\n  const passthroughAnimatedPropExplicitValues =\n    isFabric && translateY != null\n      ? {\n          style: {transform: [{translateY: translateY}]},\n        }\n      : null;\n\n  return (\n    /* $FlowFixMe[prop-missing] passthroughAnimatedPropExplicitValues isn't properly\n       included in the Animated.View flow type. */\n    <AnimatedView\n      collapsable={false}\n      nativeID={props.nativeID}\n      onLayout={_onLayout}\n      ref={_setNativeRef}\n      style={[\n        child.props.style,\n        styles.header,\n        {transform: [{translateY: animatedTranslateY}]},\n      ]}\n      passthroughAnimatedPropExplicitValues={\n        passthroughAnimatedPropExplicitValues\n      }>\n      {React.cloneElement(child, {\n        style: styles.fill, // We transfer the child style to the wrapper.\n        onLayout: undefined, // we call this manually through our this._onLayout\n      })}\n    </AnimatedView>\n  );\n});\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n    position: 'relative',\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nexport default ScrollViewStickyHeaderWithForwardedRef;\n"],"mappings":"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"}